<!DOCTYPE html>
<html>
<head>
<title>13Enum类型.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="enum-%E7%B1%BB%E5%9E%8B">Enum 类型</h1>
<p>Enum（枚举）是 TypeScript 新增的一种数据结构和类型，用来将相关常量放在一个容器里面。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Color {
    Red,     <span class="hljs-comment">// 0</span>
    Green,   <span class="hljs-comment">// 1</span>
    Blue     <span class="hljs-comment">// 2</span>
}

<span class="hljs-built_in">console</span>.log(Color.Red);  <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.log(Color[<span class="hljs-string">'Green'</span>]); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(Color[<span class="hljs-string">'Blue'</span>]); <span class="hljs-comment">// 2</span>
</div></code></pre>
<p>三个成员 <code>Red</code>、<code>Green</code> 和 <code>Blue</code>。第一个成员的值默认为整数 <code>0</code>，第二个为 <code>1</code>，第三个为 <code>2</code>，以此类推。调用 Enum 的某一个成员，与调用对象属性的写法一样，可以使用点运算符，也可以使用方扩号运算符。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> c:Color = Color.Green; <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">let</span> c:<span class="hljs-built_in">number</span> = Color.Green; <span class="hljs-comment">// 正确</span>
</div></code></pre>
<p>上面示例中，变量 <code>c</code> 的类型写成 <code>Color</code> 或 <code>number</code> 都可以。但是，<code>Color</code> 类型的语义更好。</p>
<p>Typescript 代码编译前:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Color {
  Red,
  Green,
  Blue
}
</div></code></pre>
<p>JavaScript 代码编译后：</p>
<pre class="hljs"><code><div><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">var</span> Color;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Color</span>) </span>{
    Color[Color[<span class="hljs-string">"Red"</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">"Red"</span>;
    Color[Color[<span class="hljs-string">"Green"</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">"Green"</span>;
    Color[Color[<span class="hljs-string">"Blue"</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">"Blue"</span>;
})(Color || (Color = {}));
</div></code></pre>
<p><strong>由于 TypeScript 的定位是 JavaScript 语言的类型增强，所以官方建议谨慎使用 Enum 结构，因为它不仅仅是类型，还会为编译后的代码加入一个对象。</strong></p>
<p>Enum 结构比较适合的场景是，成员的值不重要，名字更重要，从而增加代码的可读性和可维护性。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Operator {
  ADD,
  DIV,
  MUL,
  SUB
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compute</span>(<span class="hljs-params">
  op:Operator,
  a:<span class="hljs-built_in">number</span>,
  b:<span class="hljs-built_in">number</span>
</span>) </span>{
  <span class="hljs-keyword">switch</span> (op) {
    <span class="hljs-keyword">case</span> Operator.ADD:
      <span class="hljs-keyword">return</span> a + b;
    <span class="hljs-keyword">case</span> Operator.DIV:
      <span class="hljs-keyword">return</span> a / b;
    <span class="hljs-keyword">case</span> Operator.MUL:
      <span class="hljs-keyword">return</span> a * b;
    <span class="hljs-keyword">case</span> Operator.SUB:
      <span class="hljs-keyword">return</span> a - b;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'wrong operator'</span>);
  }
}

compute(Operator.ADD, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 4</span>
compute(Operator.DIV, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 2</span>
compute(Operator.ADD, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 3</span>
compute(Operator.ADD, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span>
</div></code></pre>
<p><strong>由于 Enum 结构编译后是一个对象，所以不能有与它同名的变量（包括对象、函数、类等）。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Color {
  Red,
  Green,
  Blue
}

<span class="hljs-keyword">const</span> Color = <span class="hljs-string">'red'</span>; <span class="hljs-comment">// 报错：Enum declarations can only merge with namespace or other enum declarations. 枚举声明只能与命名空间或其他枚举声明合并。</span>
</div></code></pre>
<p>上例中，Enum 结构与变量同名，导致报错。</p>
<p>Enum 结构可以被对象的 <code>as const</code> 断言替代。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Foo {
  A,
  B,
  C,
}

<span class="hljs-keyword">const</span> Bar = {
  A: <span class="hljs-number">0</span>,
  B: <span class="hljs-number">1</span>,
  C: <span class="hljs-number">2</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;

<span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
<span class="hljs-keyword">if</span> (x === Foo.A) {}
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">if</span> (x === Bar.A) {}
</div></code></pre>
<p>上面示例中，对象 <code>Bar</code> 使用了 <code>as const</code> 断言，作用就是使得它的属性无法修改。这样的话，<code>Foo</code> 和 <code>Bar</code> 的行为就很类似了，前者完全可以用后者替代，而且后者还是 JavaScript 的原生数据结构。</p>
<h2 id="1-enum-%E6%88%90%E5%91%98%E7%9A%84%E5%80%BC">1. Enum 成员的值</h2>
<p>Enum 成员默认不必赋值，系统会从零开始逐一递增，按照顺序为每个成员赋值，比如 0、1、2……，但是，也可以为 Enum 成员显式赋值。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Color {
  Red,
  Green,
  Blue
}

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">enum</span> Color {
  Red = <span class="hljs-number">0</span>,
  Green = <span class="hljs-number">1</span>,
  Blue = <span class="hljs-number">2</span>
}
</div></code></pre>
<p>成员的值可以是任意数值，但不能是大整数（Bigint）。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Enum 成员的值可以是小数，但不能是 Bigint。</span>
<span class="hljs-keyword">enum</span> Color {
  Red = <span class="hljs-number">90</span>,
  Green = <span class="hljs-number">0.5</span>,
  Blue = <span class="hljs-number">7n</span> <span class="hljs-comment">// 报错：Type 'bigint' is not assignable to type 'number' as required for computed enum member values. 类型'bigint'不能赋值给类型'number'作为计算枚举成员值的要求。</span>
}
</div></code></pre>
<p>成员的值甚至可以相同。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Color {
  Red = <span class="hljs-number">0</span>,
  Green = <span class="hljs-number">0</span>,
  Blue = <span class="hljs-number">0</span>
}
<span class="hljs-built_in">console</span>.log(Color3.Red);  <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.log(Color3[<span class="hljs-string">'Green'</span>]); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.log(Color3[<span class="hljs-string">'Blue'</span>]); <span class="hljs-comment">// 0</span>
</div></code></pre>
<p>如果只设定第一个成员的值，后面成员的值就会从这个值开始递增。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Color4 {
  Red = <span class="hljs-number">7</span>,
  Green,
  Blue
}
<span class="hljs-built_in">console</span>.log(Color4.Red);  <span class="hljs-comment">// 7</span>
<span class="hljs-built_in">console</span>.log(Color4[<span class="hljs-string">'Green'</span>]); <span class="hljs-comment">// 8</span>
<span class="hljs-built_in">console</span>.log(Color4[<span class="hljs-string">'Blue'</span>]); <span class="hljs-comment">// 9</span>

<span class="hljs-keyword">enum</span> Color5 {
  Red,
  Green = <span class="hljs-number">7</span>,
  Blue
}
<span class="hljs-built_in">console</span>.log(Color5.Red);  <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.log(Color5[<span class="hljs-string">'Green'</span>]); <span class="hljs-comment">// 7</span>
<span class="hljs-built_in">console</span>.log(Color5[<span class="hljs-string">'Blue'</span>]); <span class="hljs-comment">// 8</span>
</div></code></pre>
<p>Enum 成员的值也可以使用计算式，和函数的返回值。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> MyEnum1 {
  A = <span class="hljs-number">123</span>,
  B = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>
}

<span class="hljs-keyword">enum</span> MyEnum2 {
  A = <span class="hljs-number">123</span>,
  B = <span class="hljs-built_in">Math</span>.random(),
}
</div></code></pre>
<p>Enum 成员值都是只读的，不能重新赋值。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Color {
  Red,
  Green,
  Blue
}

Color.Red = <span class="hljs-number">4</span>; <span class="hljs-comment">// 报错：Cannot assign to 'Red' because it is a read-only property. 不能赋值给'Red'，因为它是一个只读属性。</span>
</div></code></pre>
<p>通常会在 enum 关键字前面加上 <code>const</code> 修饰，表示这是常量，不能再次赋值。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> Color {
  Red,
  Green,
  Blue
}
</div></code></pre>
<p>加上 <code>const</code> 还有一个好处，就是编译为 JavaScript 代码后，代码中 Enum 成员会被替换成对应的值，这样能提高性能表现。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> Color {
  Red,
  Green,
  Blue
}

<span class="hljs-keyword">const</span> x = Color.Red;
<span class="hljs-keyword">const</span> y = Color.Green;
<span class="hljs-keyword">const</span> z = Color.Blue;

<span class="hljs-comment">// 编译后</span>
<span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">const</span> x = <span class="hljs-number">0</span> <span class="hljs-comment">/* Color.Red */</span>;
<span class="hljs-keyword">const</span> y = <span class="hljs-number">1</span> <span class="hljs-comment">/* Color.Green */</span>;
<span class="hljs-keyword">const</span> z = <span class="hljs-number">2</span> <span class="hljs-comment">/* Color.Blue */</span>;
</div></code></pre>
<p><strong>由于 Enum 结构前面加了 <code>const</code> 关键字，所以编译产物里面就没有生成对应的对象，而是把所有 Enum 成员出现的场合，都替换成对应的常量。</strong></p>
<h2 id="2-%E5%90%8C%E5%90%8D-enum-%E7%9A%84%E5%90%88%E5%B9%B6">2. 同名 Enum 的合并</h2>
<p>多个同名的 Enum 结构会自动合并。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Foo {
  A,
}

<span class="hljs-keyword">enum</span> Foo {
  B = <span class="hljs-number">1</span>,
}

<span class="hljs-keyword">enum</span> Foo {
  C = <span class="hljs-number">2</span>,
}

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">enum</span> Foo {
  A,
  B = <span class="hljs-number">1</span>，
  C = <span class="hljs-number">2</span>
}
</div></code></pre>
<p><strong>Enum 结构合并时，只允许其中一个的首成员省略初始值，否则报错。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Foo {
  A,
}

<span class="hljs-keyword">enum</span> Foo {
  B, <span class="hljs-comment">// 报错：In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element. 在具有多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始化式。</span>
}
</div></code></pre>
<p><strong>同名 Enum 合并时，不能有同名成员，否则报错。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Foo {
  A,
  B
}

<span class="hljs-keyword">enum</span> Foo {
  B = <span class="hljs-number">1</span>, <span class="hljs-comment">// 报错： Duplicate identifier 'B'. 重复标识符'B'。</span>
  C
}
</div></code></pre>
<p><strong>同名 Enum 合并的另一个限制是，所有定义必须同为 const 枚举或者非 const 枚举，不允许混合使用。</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">enum</span> E1 {
  A,
}
<span class="hljs-keyword">enum</span> E1 {
  B = <span class="hljs-number">1</span>,
}

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> E2 {
  A,
}
<span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> E2 {
  B = <span class="hljs-number">1</span>,
}

<span class="hljs-comment">// 报错：Enum declarations can only merge with namespace or other enum declarations. 枚举声明只能与命名空间或其他枚举声明合并。</span>
<span class="hljs-keyword">enum</span> E3 {
  A,
}
<span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> E3 {
  B = <span class="hljs-number">1</span>,
}
</div></code></pre>
<p><strong>同名 Enum 的合并，最大用处就是补充外部定义的 Enum 结构。</strong></p>
<h2 id="3-%E5%AD%97%E7%AC%A6%E4%B8%B2-enum">3. 字符串 Enum</h2>
<p>Enum 成员的值除了设为数值，还可以设为字符串。也就是说，Enum 也可以用作一组相关字符串的集合。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Direction {
  Up = <span class="hljs-string">'UP'</span>,
  Down = <span class="hljs-string">'DOWN'</span>,
  Left = <span class="hljs-string">'LEFT'</span>,
  Right = <span class="hljs-string">'RIGHT'</span>,
}
</div></code></pre>
<p>Direction 就是字符串枚举，每个成员的值都是字符串。</p>
<p><strong>字符串枚举的所有成员值，都必须显式设置。如果没有设置，成员值默认为数值，且位置必须在字符串成员之前。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Foo1 {
  A, <span class="hljs-comment">// 0， 第一个成员不设初始值默认为 0</span>
  B = <span class="hljs-string">'hello'</span>,
  C <span class="hljs-comment">// 报错： Enum member must have initializer. 枚举成员必须有初始化式。</span>
}

<span class="hljs-comment">// 成员的类型可以是 number 和 string，两者可以混合在一个 Enum 中</span>
<span class="hljs-keyword">enum</span> Foo2 {
  A = <span class="hljs-number">1</span>,
  B = <span class="hljs-string">'hello'</span>,
  C = <span class="hljs-number">0</span>
}

<span class="hljs-keyword">enum</span> Foo3 {
  A, <span class="hljs-comment">// 0</span>
  B = <span class="hljs-string">'hello'</span>,
  C = <span class="hljs-string">'world'</span>
}
</div></code></pre>
<p><code>A</code> 之前没有其他成员，所以可以不设置初始值，默认等于 <code>0</code>；<code>C</code> 之前有一个字符串成员，所以 <code>C</code> 必须有初始值，不赋值就报错了。</p>
<p><strong>Enum 成员可以是字符串和数值混合赋值。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Enum {
  One = <span class="hljs-string">'One'</span>,
  Two = <span class="hljs-string">'Two'</span>,
  Three = <span class="hljs-number">3</span>,
  Four = <span class="hljs-number">4</span>,
}
</div></code></pre>
<p>除了数值和字符串，Enum 成员不允许使用其他值（比如 <code>Symbol</code>、<code>Boolean</code>）。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Foo {
  A = <span class="hljs-literal">true</span> <span class="hljs-comment">// 报错：Type 'boolean' is not assignable to type 'number' as required for computed enum member values. 类型“boolean”不能赋值给类型“number”，因为计算枚举成员值需要赋值。</span>
}

<span class="hljs-keyword">enum</span> Foo2 {
  A = <span class="hljs-literal">true</span> <span class="hljs-comment">// 报错：Type 'symbol' is not assignable to type 'number' as required for computed enum member values. 类型“symbol”不能赋值给类型“number”，因为计算枚举成员值需要赋值。</span>
}
</div></code></pre>
<p><strong>变量类型如果是字符串 Enum，就不能再赋值为字符串，这跟数值 Enum 不一样。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> MyEnum {
  One = <span class="hljs-string">'One'</span>,
  Two = <span class="hljs-string">'Two'</span>,
}

<span class="hljs-keyword">let</span> s = MyEnum.One;
s = <span class="hljs-string">'One'</span>; <span class="hljs-comment">// 报错：Type '"One"' is not assignable to type 'MyEnum'.</span>
</div></code></pre>
<p>上面示例中，变量s的类型是MyEnum，再赋值为字符串就报错。由于这个原因，如果函数的参数类型是字符串 Enum，传参时就不能直接传入字符串，而要传入 Enum 成员。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> MyEnum {
  One = <span class="hljs-string">'One'</span>,
  Two = <span class="hljs-string">'Two'</span>,
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">arg:MyEnum</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'arg is '</span> + arg;
}

f(MyEnum[<span class="hljs-string">'One'</span>]) <span class="hljs-comment">// 正确</span>
f(MyEnum.One) <span class="hljs-comment">// 正确</span>

f(<span class="hljs-string">'One'</span>) <span class="hljs-comment">// 报错： Argument of type '"One"' is not assignable to parameter of type 'MyEnum'.</span>
</div></code></pre>
<p>Enum 成员值可以保存一些有用的信息，所以 TypeScript 才设计了字符串 Enum。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> MediaTypes {
  <span class="hljs-built_in">JSON</span> = <span class="hljs-string">'application/json'</span>,
  XML = <span class="hljs-string">'application/xml'</span>,
}
<span class="hljs-keyword">const</span> url = <span class="hljs-string">'localhost'</span>;
fetch(url, {
  headers: {
    Accept: MediaTypes.JSON,
  },
}).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
  <span class="hljs-comment">// ...</span>
});
</div></code></pre>
<p>上面示例中，函数 <code>fetch()</code> 的参数对象的属性 <code>Accept</code> ，只能接受一些指定的字符串。这时就很适合把字符串放进一个 Enum 结构，通过成员值来引用这些字符串。</p>
<p><strong>字符串 Enum 可以使用联合类型（union）代替。</strong> 效果跟指定为字符串 Enum 是一样的</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span> (<span class="hljs-params">where:'Up'|'Down'|'Left'|'Right'</span>) </span>{
  <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p><strong>字符串 Enum 的成员值，不能使用字符串表达式赋值。可以使用数值表达式、函数返回值，和可以转换为数值的计算值。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> MyEnum1 {
  A = <span class="hljs-string">'one'</span>,
  B = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>].join(<span class="hljs-string">''</span>) <span class="hljs-comment">// 报错：Type 'string' is not assignable to type 'number' as required for computed enum member values. 类型“string”不能按计算枚举成员值的要求赋值给类型“number”。</span>
}
<span class="hljs-keyword">enum</span> MyEnum2 {
  A = <span class="hljs-string">'one'</span>,
  B = <span class="hljs-built_in">String</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错：Type 'string' is not assignable to type 'number' as required for computed enum member values.</span>
}
<span class="hljs-keyword">enum</span> MyEnum3 {
  A = <span class="hljs-number">123</span>,
  B = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>][<span class="hljs-number">0</span>] <span class="hljs-comment">// 报错：Type 'string' is not assignable to type 'number' as required for computed enum member values.</span>
}

<span class="hljs-keyword">enum</span> MyEnum10 {
  A = <span class="hljs-string">'one'</span>,
  B = <span class="hljs-built_in">Number</span>([<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>].join(<span class="hljs-string">''</span>)), <span class="hljs-comment">// 正确，数值表达式</span>
}
<span class="hljs-keyword">enum</span> MyEnum11 {
  A = <span class="hljs-string">'one'</span>,
  B = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'1'</span>) <span class="hljs-comment">// 正确</span>
}
<span class="hljs-keyword">enum</span> MyEnum12 {
  A = <span class="hljs-number">123</span>,
  B = <span class="hljs-built_in">Number</span>([<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>][<span class="hljs-number">0</span>]) <span class="hljs-comment">// 正确</span>
}
<span class="hljs-keyword">enum</span> MyEnum13 {
  A = <span class="hljs-number">123</span>,
  B = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] <span class="hljs-comment">// 正确</span>
}
<span class="hljs-keyword">enum</span> MyEnum14 {
  A = <span class="hljs-number">123</span>,
  B = <span class="hljs-built_in">Math</span>.random(), <span class="hljs-comment">// 正确，函数返回值</span>
}
<span class="hljs-keyword">enum</span> MyEnum15 {
  A = <span class="hljs-number">123</span>,
  B = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-comment">// 正确，数值计算值</span>
}
<span class="hljs-keyword">enum</span> MyEnum16 {
  A = <span class="hljs-number">123</span>,
  B = <span class="hljs-string">'1'</span> + <span class="hljs-string">'2'</span>, <span class="hljs-comment">// 正确</span>
}
<span class="hljs-keyword">type</span> e = {[key <span class="hljs-keyword">in</span> MyEnum16]: <span class="hljs-built_in">number</span>};  <span class="hljs-comment">// type e = { 123: number; 12: number; }</span>
</div></code></pre>
<p>成员 <code>B</code> 的值是一个字符串表达式，导致报错。</p>
<h2 id="4-keyof-%E8%BF%90%E7%AE%97%E7%AC%A6">4. keyof 运算符</h2>
<p><strong>keyof 运算符可以取出 Enum 结构的所有成员名，作为联合类型返回。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> MyEnum {
  A = <span class="hljs-string">'a'</span>,
  B = <span class="hljs-string">'b'</span>
}

<span class="hljs-keyword">type</span> Foo = keyof <span class="hljs-keyword">typeof</span> MyEnum;  <span class="hljs-comment">// type Foo = "A" | "B"</span>
</div></code></pre>
<p><code>keyof typeof MyEnum</code> 可以取出 <code>MyEnum</code> 的所有成员名，所以类型 <code>Foo</code> 等同于联合类型<code>'A'|'B'</code>。</p>
<p><strong>这里的 <code>typeof</code> 是必需的，否则 <code>keyof MyEnum</code> 相当于 <code>keyof number</code> 。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> Foo = keyof MyEnum;
<span class="hljs-comment">// "toString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf" | "toLocaleString"</span>
</div></code></pre>
<p>这是因为 Enum 作为类型，本质上属于 <code>number</code> 或 <code>string</code> 的一种变体，而 <code>typeof MyEnum</code> 会将 <code>MyEnum</code> 当作一个值处理，从而先其转为对象类型，就可以再用 <code>keyof</code> 运算符返回该对象的所有属性名。</p>
<p><strong>如果要返回 Enum 所有的成员值，可以使用 <code>in</code> 运算符。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> MyEnum13 {
  A = <span class="hljs-string">'a'</span>,
  B = <span class="hljs-string">'b'</span>
}
<span class="hljs-keyword">type</span> Foo13 = { [key <span class="hljs-keyword">in</span> MyEnum]: <span class="hljs-built_in">number</span> }; <span class="hljs-comment">// type Foo13 = { a: number; b: number; }</span>
</div></code></pre>
<h2 id="5-%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84">5. 反向映射</h2>
<p><strong>数值 Enum 存在反向映射，即可以通过成员值获得成员名。</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Weekdays {
  Monday = <span class="hljs-number">1</span>,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday,
  Sunday
}

<span class="hljs-built_in">console</span>.log(Weekdays[<span class="hljs-number">3</span>]) <span class="hljs-comment">// Wednesday</span>
<span class="hljs-built_in">console</span>.log(Weekdays[<span class="hljs-string">'Wednesday'</span>]) <span class="hljs-comment">// 3</span>
</div></code></pre>
<p>上面示例中，Enum 成员 <code>Wednesday</code> 的值等于 <code>3</code>，从而可以从成员值 <code>3</code> 取到对应的成员名 <code>Wednesday</code>，这是反向映射。</p>
<p>这是因为 TypeScript 会将上面的 Enum 结构，编译成下面的 JavaScript 代码。</p>
<pre class="hljs"><code><div><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">var</span> Weekdays;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Weekdays</span>) </span>{
    Weekdays[Weekdays[<span class="hljs-string">"Monday"</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">"Monday"</span>;
    Weekdays[Weekdays[<span class="hljs-string">"Tuesday"</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">"Tuesday"</span>;
    Weekdays[Weekdays[<span class="hljs-string">"Wednesday"</span>] = <span class="hljs-number">3</span>] = <span class="hljs-string">"Wednesday"</span>;
    Weekdays[Weekdays[<span class="hljs-string">"Thursday"</span>] = <span class="hljs-number">4</span>] = <span class="hljs-string">"Thursday"</span>;
    Weekdays[Weekdays[<span class="hljs-string">"Friday"</span>] = <span class="hljs-number">5</span>] = <span class="hljs-string">"Friday"</span>;
    Weekdays[Weekdays[<span class="hljs-string">"Saturday"</span>] = <span class="hljs-number">6</span>] = <span class="hljs-string">"Saturday"</span>;
    Weekdays[Weekdays[<span class="hljs-string">"Sunday"</span>] = <span class="hljs-number">7</span>] = <span class="hljs-string">"Sunday"</span>;
})(Weekdays || (Weekdays = {}));
</div></code></pre>
<p>上面代码中，实际进行了两组赋值，以第一个成员为例。</p>
<pre class="hljs"><code><div>Weekdays[Weekdays[<span class="hljs-string">"Monday"</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">"Monday"</span>;
</div></code></pre>
<p>上面代码有两个赋值运算符（=），实际上等同于下面的代码。</p>
<pre class="hljs"><code><div>Weekdays[<span class="hljs-string">"Monday"</span>] = <span class="hljs-number">1</span>;
Weekdays[<span class="hljs-number">1</span>] = <span class="hljs-string">"Monday"</span>;
</div></code></pre>
<p><strong>这种情况只发生在数值 Enum，对于字符串 Enum，不存在反向映射。这是因为字符串 Enum 编译后只有一组赋值。</strong></p>
<p>编译前</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> MyEnum {
  A = <span class="hljs-string">'a'</span>,
  B = <span class="hljs-string">'b'</span>
}
</div></code></pre>
<p>编译后：</p>
<pre class="hljs"><code><div><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">var</span> MyEnum;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">MyEnum</span>) </span>{
    MyEnum[<span class="hljs-string">"A"</span>] = <span class="hljs-string">"a"</span>;
    MyEnum[<span class="hljs-string">"B"</span>] = <span class="hljs-string">"b"</span>;
})(MyEnum || (MyEnum = {}));
</div></code></pre>

</body>
</html>
